/**
 * Robolucha API
 * Robolucha API
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ModelActiveMatch } from '../model/modelActiveMatch';
import { ModelActivity } from '../model/modelActivity';
import { ModelAvailableMatch } from '../model/modelAvailableMatch';
import { ModelBulkConfig } from '../model/modelBulkConfig';
import { ModelClassroom } from '../model/modelClassroom';
import { ModelConfig } from '../model/modelConfig';
import { ModelFindLuchadorWithGamedefinition } from '../model/modelFindLuchadorWithGamedefinition';
import { ModelGameComponent } from '../model/modelGameComponent';
import { ModelGameDefinition } from '../model/modelGameDefinition';
import { ModelJoinMatch } from '../model/modelJoinMatch';
import { ModelLevelGroup } from '../model/modelLevelGroup';
import { ModelMatch } from '../model/modelMatch';
import { ModelMatchMetric } from '../model/modelMatchMetric';
import { ModelMatchParticipant } from '../model/modelMatchParticipant';
import { ModelMatchScore } from '../model/modelMatchScore';
import { ModelMedia } from '../model/modelMedia';
import { ModelMediaRequest } from '../model/modelMediaRequest';
import { ModelPageEventRequest } from '../model/modelPageEventRequest';
import { ModelPlayRequest } from '../model/modelPlayRequest';
import { ModelScoreList } from '../model/modelScoreList';
import { ModelStudentResponse } from '../model/modelStudentResponse';
import { ModelUpdateLuchadorResponse } from '../model/modelUpdateLuchadorResponse';
import { ModelUserDetails } from '../model/modelUserDetails';
import { ModelUserSetting } from '../model/modelUserSetting';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://http://local.robolucha.com:5000';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * find existing activities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assignmentidActivitiesPatch(observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public assignmentidActivitiesPatch(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public assignmentidActivitiesPatch(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public assignmentidActivitiesPatch(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.patch<Array<number>>(`${this.basePath}/assignment/:id/activities`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find existing activities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assignmentidStudentsPatch(observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public assignmentidStudentsPatch(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public assignmentidStudentsPatch(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public assignmentidStudentsPatch(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.patch<Array<number>>(`${this.basePath}/assignment/:id/students`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find existing activities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardActivityGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelActivity>>;
    public dashboardActivityGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelActivity>>>;
    public dashboardActivityGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelActivity>>>;
    public dashboardActivityGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelActivity>>(`${this.basePath}/dashboard/activity`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find existing activities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardAssignmentsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelActivity>>;
    public dashboardAssignmentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelActivity>>>;
    public dashboardAssignmentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelActivity>>>;
    public dashboardAssignmentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelActivity>>(`${this.basePath}/dashboard/assignments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find existing activities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardAssignmentsPost(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelActivity>>;
    public dashboardAssignmentsPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelActivity>>>;
    public dashboardAssignmentsPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelActivity>>>;
    public dashboardAssignmentsPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<ModelActivity>>(`${this.basePath}/dashboard/assignments`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find all Classroom
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardClassroomGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelClassroom>>;
    public dashboardClassroomGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelClassroom>>>;
    public dashboardClassroomGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelClassroom>>>;
    public dashboardClassroomGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelClassroom>>(`${this.basePath}/dashboard/classroom`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * add a Classroom
     * 
     * @param request Classroom
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardClassroomPost(request: ModelClassroom, observe?: 'body', reportProgress?: boolean): Observable<ModelClassroom>;
    public dashboardClassroomPost(request: ModelClassroom, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelClassroom>>;
    public dashboardClassroomPost(request: ModelClassroom, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelClassroom>>;
    public dashboardClassroomPost(request: ModelClassroom, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling dashboardClassroomPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelClassroom>(`${this.basePath}/dashboard/classroom`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find all Classroom students
     * 
     * @param id Classroom id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardClassroomStudentsIdGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelStudentResponse>>;
    public dashboardClassroomStudentsIdGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelStudentResponse>>>;
    public dashboardClassroomStudentsIdGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelStudentResponse>>>;
    public dashboardClassroomStudentsIdGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dashboardClassroomStudentsIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelStudentResponse>>(`${this.basePath}/dashboard/classroom/students/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find The current user information
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dashboardGetUserGet(observe?: 'body', reportProgress?: boolean): Observable<ModelUserDetails>;
    public dashboardGetUserGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelUserDetails>>;
    public dashboardGetUserGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelUserDetails>>;
    public dashboardGetUserGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelUserDetails>(`${this.basePath}/dashboard/get-user`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * get default game definition
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDefaultGameDefinition(observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public getDefaultGameDefinition(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public getDefaultGameDefinition(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public getDefaultGameDefinition(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelGameDefinition>(`${this.basePath}/private/mapeditor/default`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * saves a match score
     * 
     * @param request ScoreList
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalAddMatchScoresPost(request: ModelScoreList, observe?: 'body', reportProgress?: boolean): Observable<ModelMatchScore>;
    public internalAddMatchScoresPost(request: ModelScoreList, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatchScore>>;
    public internalAddMatchScoresPost(request: ModelScoreList, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatchScore>>;
    public internalAddMatchScoresPost(request: ModelScoreList, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalAddMatchScoresPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelMatchScore>(`${this.basePath}/internal/add-match-scores`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * ends existing match
     * 
     * @param request Match
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalEndMatchPut(request: ModelMatch, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public internalEndMatchPut(request: ModelMatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public internalEndMatchPut(request: ModelMatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public internalEndMatchPut(request: ModelMatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalEndMatchPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModelMatch>(`${this.basePath}/internal/end-match`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Gamecomponent as Luchador
     * 
     * @param request Luchador
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalGameComponentPost(request: ModelGameComponent, observe?: 'body', reportProgress?: boolean): Observable<ModelGameComponent>;
    public internalGameComponentPost(request: ModelGameComponent, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameComponent>>;
    public internalGameComponentPost(request: ModelGameComponent, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameComponent>>;
    public internalGameComponentPost(request: ModelGameComponent, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalGameComponentPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelGameComponent>(`${this.basePath}/internal/game-component`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find a game definition
     * 
     * @param id GameDefinition id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalGameDefinitionIdIdGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public internalGameDefinitionIdIdGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public internalGameDefinitionIdIdGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public internalGameDefinitionIdIdGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling internalGameDefinitionIdIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelGameDefinition>(`${this.basePath}/internal/game-definition-id/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find a game definition
     * 
     * @param name GameDefinition name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalGameDefinitionNameGet(name: string, observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public internalGameDefinitionNameGet(name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public internalGameDefinitionNameGet(name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public internalGameDefinitionNameGet(name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling internalGameDefinitionNameGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelGameDefinition>(`${this.basePath}/internal/game-definition/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * create Game definition
     * 
     * @param request GameDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalGameDefinitionPost(request: ModelGameDefinition, observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public internalGameDefinitionPost(request: ModelGameDefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public internalGameDefinitionPost(request: ModelGameDefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public internalGameDefinitionPost(request: ModelGameDefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalGameDefinitionPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelGameDefinition>(`${this.basePath}/internal/game-definition`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * update Game definition
     * 
     * @param request GameDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalGameDefinitionPut(request: ModelGameDefinition, observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public internalGameDefinitionPut(request: ModelGameDefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public internalGameDefinitionPut(request: ModelGameDefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public internalGameDefinitionPut(request: ModelGameDefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalGameDefinitionPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModelGameDefinition>(`${this.basePath}/internal/game-definition`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find Luchador by ID
     * 
     * @param request FindLuchadorWithGamedefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalLuchadorPost(request: ModelFindLuchadorWithGamedefinition, observe?: 'body', reportProgress?: boolean): Observable<ModelGameComponent>;
    public internalLuchadorPost(request: ModelFindLuchadorWithGamedefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameComponent>>;
    public internalLuchadorPost(request: ModelFindLuchadorWithGamedefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameComponent>>;
    public internalLuchadorPost(request: ModelFindLuchadorWithGamedefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalLuchadorPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelGameComponent>(`${this.basePath}/internal/luchador`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * saves a match metric
     * 
     * @param request MatchMetric
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalMatchMetricPost(request: ModelMatchMetric, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public internalMatchMetricPost(request: ModelMatchMetric, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public internalMatchMetricPost(request: ModelMatchMetric, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public internalMatchMetricPost(request: ModelMatchMetric, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalMatchMetricPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/internal/match-metric`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds luchador to a match
     * 
     * @param request MatchParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalMatchParticipantPost(request: ModelMatchParticipant, observe?: 'body', reportProgress?: boolean): Observable<ModelMatchParticipant>;
    public internalMatchParticipantPost(request: ModelMatchParticipant, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatchParticipant>>;
    public internalMatchParticipantPost(request: ModelMatchParticipant, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatchParticipant>>;
    public internalMatchParticipantPost(request: ModelMatchParticipant, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalMatchParticipantPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelMatchParticipant>(`${this.basePath}/internal/match-participant`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find one match
     * 
     * @param matchID int valid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalMatchSingleGet(matchID?: number, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public internalMatchSingleGet(matchID?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public internalMatchSingleGet(matchID?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public internalMatchSingleGet(matchID?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchID !== undefined) {
            queryParameters = queryParameters.set('matchID', <any>matchID);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelMatch>(`${this.basePath}/internal/match-single`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * returns application health check information
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalReadyGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public internalReadyGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public internalReadyGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public internalReadyGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/internal/ready`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * notify that the match is running, all participants joined
     * 
     * @param request Match
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public internalRunMatchPut(request: ModelMatch, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public internalRunMatchPut(request: ModelMatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public internalRunMatchPut(request: ModelMatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public internalRunMatchPut(request: ModelMatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling internalRunMatchPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModelMatch>(`${this.basePath}/internal/run-match`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find available matches by classroom
     * 
     * @param id Classroom id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateAvailableMatchClassroomIdGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelAvailableMatch>>;
    public privateAvailableMatchClassroomIdGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchClassroomIdGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchClassroomIdGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling privateAvailableMatchClassroomIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelAvailableMatch>>(`${this.basePath}/private/available-match-classroom/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find available matches by classroom owned by the user
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateAvailableMatchClassroomOwnedGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelAvailableMatch>>;
    public privateAvailableMatchClassroomOwnedGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchClassroomOwnedGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchClassroomOwnedGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelAvailableMatch>>(`${this.basePath}/private/available-match-classroom-owned`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find all public available matches
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateAvailableMatchPublicGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelAvailableMatch>>;
    public privateAvailableMatchPublicGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchPublicGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelAvailableMatch>>>;
    public privateAvailableMatchPublicGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelAvailableMatch>>(`${this.basePath}/private/available-match-public`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find all game definitions
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateGameDefinitionAllGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelGameDefinition>>;
    public privateGameDefinitionAllGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelGameDefinition>>>;
    public privateGameDefinitionAllGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelGameDefinition>>>;
    public privateGameDefinitionAllGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelGameDefinition>>(`${this.basePath}/private/game-definition-all`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find a game definition
     * 
     * @param id GameDefinition id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateGameDefinitionIdIdGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<ModelGameDefinition>;
    public privateGameDefinitionIdIdGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameDefinition>>;
    public privateGameDefinitionIdIdGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameDefinition>>;
    public privateGameDefinitionIdIdGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling privateGameDefinitionIdIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelGameDefinition>(`${this.basePath}/private/game-definition-id/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find The current user information
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateGetUserGet(observe?: 'body', reportProgress?: boolean): Observable<ModelUserDetails>;
    public privateGetUserGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelUserDetails>>;
    public privateGetUserGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelUserDetails>>;
    public privateGetUserGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelUserDetails>(`${this.basePath}/private/get-user`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * join a classroom
     * 
     * @param accessCode classroom access code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateJoinClassroomAccessCodePost(accessCode: string, observe?: 'body', reportProgress?: boolean): Observable<ModelClassroom>;
    public privateJoinClassroomAccessCodePost(accessCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelClassroom>>;
    public privateJoinClassroomAccessCodePost(accessCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelClassroom>>;
    public privateJoinClassroomAccessCodePost(accessCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accessCode === null || accessCode === undefined) {
            throw new Error('Required parameter accessCode was null or undefined when calling privateJoinClassroomAccessCodePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<ModelClassroom>(`${this.basePath}/private/join-classroom/${encodeURIComponent(String(accessCode))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sends message with the request to join the match
     * 
     * @param request JoinMatch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateJoinMatchPost(request: ModelJoinMatch, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public privateJoinMatchPost(request: ModelJoinMatch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public privateJoinMatchPost(request: ModelJoinMatch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public privateJoinMatchPost(request: ModelJoinMatch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateJoinMatchPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelMatch>(`${this.basePath}/private/join-match`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sends message to end active tutorial matches
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateLeaveTutorialMatchPost(observe?: 'body', reportProgress?: boolean): Observable<string>;
    public privateLeaveTutorialMatchPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public privateLeaveTutorialMatchPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public privateLeaveTutorialMatchPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<string>(`${this.basePath}/private/leave-tutorial-match`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find all level groups
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateLevelGroupGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelLevelGroup>>;
    public privateLevelGroupGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelLevelGroup>>>;
    public privateLevelGroupGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelLevelGroup>>>;
    public privateLevelGroupGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelLevelGroup>>(`${this.basePath}/private/level-group`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find or create Luchador for the current user
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateLuchadorGet(observe?: 'body', reportProgress?: boolean): Observable<ModelGameComponent>;
    public privateLuchadorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelGameComponent>>;
    public privateLuchadorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelGameComponent>>;
    public privateLuchadorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelGameComponent>(`${this.basePath}/private/luchador`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates Luchador
     * 
     * @param request Luchador
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateLuchadorPut(request: ModelGameComponent, observe?: 'body', reportProgress?: boolean): Observable<ModelUpdateLuchadorResponse>;
    public privateLuchadorPut(request: ModelGameComponent, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelUpdateLuchadorResponse>>;
    public privateLuchadorPut(request: ModelGameComponent, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelUpdateLuchadorResponse>>;
    public privateLuchadorPut(request: ModelGameComponent, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateLuchadorPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModelUpdateLuchadorResponse>(`${this.basePath}/private/luchador`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find my gamedefitions
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMapeditorGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelGameDefinition>>;
    public privateMapeditorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelGameDefinition>>>;
    public privateMapeditorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelGameDefinition>>>;
    public privateMapeditorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelGameDefinition>>(`${this.basePath}/private/mapeditor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * add a single gamedefition for this user
     * 
     * @param request GameDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMapeditorPost(request: ModelGameDefinition, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public privateMapeditorPost(request: ModelGameDefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public privateMapeditorPost(request: ModelGameDefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public privateMapeditorPost(request: ModelGameDefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateMapeditorPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/private/mapeditor`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * update gamedefition for this user
     * 
     * @param request GameDefinition
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMapeditorPut(request: ModelGameDefinition, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelGameDefinition>>;
    public privateMapeditorPut(request: ModelGameDefinition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelGameDefinition>>>;
    public privateMapeditorPut(request: ModelGameDefinition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelGameDefinition>>>;
    public privateMapeditorPut(request: ModelGameDefinition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateMapeditorPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<Array<ModelGameDefinition>>(`${this.basePath}/private/mapeditor`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find maskConfig for a luchador
     * 
     * @param id Luchador ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMaskConfigIdGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelConfig>>;
    public privateMaskConfigIdGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelConfig>>>;
    public privateMaskConfigIdGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelConfig>>>;
    public privateMaskConfigIdGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling privateMaskConfigIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelConfig>>(`${this.basePath}/private/mask-config/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * create random maskConfig in bulk
     * 
     * @param amount Amount of random configs, max 2048
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMaskRandomBulkAmountGet(amount: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelBulkConfig>>;
    public privateMaskRandomBulkAmountGet(amount: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelBulkConfig>>>;
    public privateMaskRandomBulkAmountGet(amount: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelBulkConfig>>>;
    public privateMaskRandomBulkAmountGet(amount: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling privateMaskRandomBulkAmountGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelBulkConfig>>(`${this.basePath}/private/mask-random-bulk/${encodeURIComponent(String(amount))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * create random maskConfig
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMaskRandomGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelConfig>>;
    public privateMaskRandomGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelConfig>>>;
    public privateMaskRandomGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelConfig>>>;
    public privateMaskRandomGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelConfig>>(`${this.basePath}/private/mask-random`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * return luchador configs for current match
     * 
     * @param matchID int valid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMatchConfigGet(matchID?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelGameComponent>>;
    public privateMatchConfigGet(matchID?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelGameComponent>>>;
    public privateMatchConfigGet(matchID?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelGameComponent>>>;
    public privateMatchConfigGet(matchID?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchID !== undefined) {
            queryParameters = queryParameters.set('matchID', <any>matchID);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelGameComponent>>(`${this.basePath}/private/match-config`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find active matches
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMatchGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelActiveMatch>>;
    public privateMatchGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelActiveMatch>>>;
    public privateMatchGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelActiveMatch>>>;
    public privateMatchGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelActiveMatch>>(`${this.basePath}/private/match`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find active multiplayer matches
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMatchMultiplayerGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelMatch>>;
    public privateMatchMultiplayerGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelMatch>>>;
    public privateMatchMultiplayerGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelMatch>>>;
    public privateMatchMultiplayerGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelMatch>>(`${this.basePath}/private/match-multiplayer`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find one match score
     * 
     * @param matchID int valid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMatchScoreGet(matchID?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModelMatchScore>>;
    public privateMatchScoreGet(matchID?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelMatchScore>>>;
    public privateMatchScoreGet(matchID?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelMatchScore>>>;
    public privateMatchScoreGet(matchID?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchID !== undefined) {
            queryParameters = queryParameters.set('matchID', <any>matchID);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelMatchScore>>(`${this.basePath}/private/match-score`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find one match
     * 
     * @param matchID int valid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMatchSingleGet(matchID?: number, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public privateMatchSingleGet(matchID?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public privateMatchSingleGet(matchID?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public privateMatchSingleGet(matchID?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchID !== undefined) {
            queryParameters = queryParameters.set('matchID', <any>matchID);
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelMatch>(`${this.basePath}/private/match-single`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * add media
     * 
     * @param request MediaRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateMediaPost(request: ModelMediaRequest, observe?: 'body', reportProgress?: boolean): Observable<ModelMedia>;
    public privateMediaPost(request: ModelMediaRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMedia>>;
    public privateMediaPost(request: ModelMediaRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMedia>>;
    public privateMediaPost(request: ModelMediaRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateMediaPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelMedia>(`${this.basePath}/private/media`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * add page events
     * 
     * @param request PageEventRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privatePageEventsPost(request: ModelPageEventRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public privatePageEventsPost(request: ModelPageEventRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public privatePageEventsPost(request: ModelPageEventRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public privatePageEventsPost(request: ModelPageEventRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privatePageEventsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/private/page-events`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * request to play a match
     * 
     * @param request PlayRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privatePlayPost(request: ModelPlayRequest, observe?: 'body', reportProgress?: boolean): Observable<ModelMatch>;
    public privatePlayPost(request: ModelPlayRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelMatch>>;
    public privatePlayPost(request: ModelPlayRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelMatch>>;
    public privatePlayPost(request: ModelPlayRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privatePlayPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ModelMatch>(`${this.basePath}/private/play`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find tutorial GameDefinition
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateTutorialGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelGameDefinition>>;
    public privateTutorialGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelGameDefinition>>>;
    public privateTutorialGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelGameDefinition>>>;
    public privateTutorialGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModelGameDefinition>>(`${this.basePath}/private/tutorial`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * find current user userSetting
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateUserSettingGet(observe?: 'body', reportProgress?: boolean): Observable<ModelUserSetting>;
    public privateUserSettingGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelUserSetting>>;
    public privateUserSettingGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelUserSetting>>;
    public privateUserSettingGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModelUserSetting>(`${this.basePath}/private/user/setting`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates user userSetting
     * 
     * @param request UserSetting
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public privateUserSettingPut(request: ModelUserSetting, observe?: 'body', reportProgress?: boolean): Observable<ModelUserSetting>;
    public privateUserSettingPut(request: ModelUserSetting, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelUserSetting>>;
    public privateUserSettingPut(request: ModelUserSetting, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelUserSetting>>;
    public privateUserSettingPut(request: ModelUserSetting, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling privateUserSettingPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (ApiKeyAuth) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModelUserSetting>(`${this.basePath}/private/user/setting`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
